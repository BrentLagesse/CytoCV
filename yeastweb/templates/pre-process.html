<!-- Navigation bar -->
{% extends 'base.html' %}
<!-- Template specific content -->
{% block content %}
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const raw = sessionStorage.getItem("dvErrors");
    if (!raw) return;
    let lines = [];
    try {
      lines = JSON.parse(raw) || [];
    } catch (err) {
      sessionStorage.removeItem("dvErrors");
      return;
    }
    sessionStorage.removeItem("dvErrors");
    if (!Array.isArray(lines) || lines.length === 0) return;

    let container = document.querySelector(".message-container.dv-overlay");
    if (!container) {
      container = document.createElement("div");
      container.className = "message-container dv-overlay";
      Object.assign(container.style, {
        position: "fixed",
        top: "calc(var(--nav-height) + 6px)",
        left: "50%",
        transform: "translateX(-50%)",
        width: "calc(100% - 32px)",
        maxWidth: "720px",
        zIndex: "2000",
        pointerEvents: "none",
        margin: "0",
        padding: "0",
      });
      document.body.appendChild(container);
    }

    const key = lines.filter((line) => line).join("\n").trim() || "dv-errors";
    const existing = Array.from(
      container.querySelectorAll(".message.dv-error")
    ).some((msg) => msg.dataset.key === key);
    if (existing) return;

    const formattedLines = lines
      .map((line) => {
        if (!line) {
          return '<div style="height:1px; background: rgba(255, 255, 255, 0.08); margin:6px 0;"></div>';
        }
        const isHeader = line.startsWith("Could not process");
        const cleanedLine = isHeader
          ? line
          : line
              .replace(/\s*\(expected\s*\d+\s*layers?\)/i, "")
              .replace(/\s*\(expected\s*\d+\s*\)/i, "");
        const weight = isHeader ? "600" : "400";
        return `<div style="font-weight:${weight};">${cleanedLine}</div>`;
      })
      .join("");
    const hasSections = lines.some((line) => !line);
    const headerLine = hasSections
      ? '<div style="font-weight:600; margin-bottom:4px;">Validation issues:</div><div style="height:1px; background: rgba(255, 255, 255, 0.08); margin:6px 0;"></div>'
      : "";

    const message = document.createElement("div");
    message.className = "message dv-error";
    message.dataset.key = key;
    message.innerHTML = `${headerLine}${formattedLines}`;
    message.style.position = "relative";
    message.style.paddingRight = "32px";
    message.style.fontSize = "16px";
    message.style.lineHeight = "1.45";
    message.style.pointerEvents = "auto";
    const close = document.createElement("button");
    close.type = "button";
    close.setAttribute("aria-label", "Dismiss");
    close.innerHTML = "&times;";
    Object.assign(close.style, {
      position: "absolute",
      top: "6px",
      right: "10px",
      background: "#3b1a1f",
      border: "none",
      color: "inherit",
      fontSize: "20px",
      cursor: "pointer",
      lineHeight: "1",
      padding: "2px 8px",
      borderRadius: "6px",
    });
    close.addEventListener("mouseenter", () => {
      close.style.background = "#5a2a31";
    });
    close.addEventListener("mouseleave", () => {
      close.style.background = "#3b1a1f";
    });
    close.addEventListener("click", () => message.remove());
    message.appendChild(close);
    container.prepend(message);
    setTimeout(() => message.remove(), 60000);
  });
</script>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pre-process</title>
    <style>
      .channel-chip.dic { background-color: black; }
      .channel-chip.dapi { background-color: blue; }
      .channel-chip.mcherry { background-color: red; }
      .channel-chip.gfp { background-color: green; }

      /* Overall page styling */
      body {
        margin: 0;
        font-family: var(--app-font);
        background-color: var(--page-bg);
        color: var(--text);
        padding: calc(var(--nav-height) + 10px) 10px 10px;
      }

      .page-container {
        display: flex;
        flex-direction: row;
        width: 100%;
        min-height: calc(100dvh - var(--nav-height));
        align-items: stretch;
        gap: 10px;
      }

      /* SIDEBAR */
      .sidebar {
        position: relative;
        width: 400px;
        background-color: var(--card-bg);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        transition: width 0.3s ease, background-color 0.2s ease; 
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-self: stretch;
      }

      /* Collapsed state: set width to something minimal */
      .sidebar.collapsed { width: 60px; background-color: var(--card-bg); }

      /* Hide text + content when collapsed */
      .sidebar.collapsed .sidebar-header h2,
      .sidebar.collapsed .sidebar-content { display: none; }

      /* Explicity cancel hover when it’s open (this is to prevent any unessesary flashing)*/
      .sidebar:hover { background-color: #222; }

      /* Only lighten when collapsed AND hovered */
      .sidebar.collapsed:hover { background-color: #2f2f2f; }

      /* Sidebar header */
      .sidebar-header {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #1f1f1f;
        border-radius: 12px;
        margin: 10px 12px;
        padding: 10px;
      }
      .sidebar-header h2 { margin: 0; font-size: 18px; }

      /* Toggle button */
      .toggle-btn {
        position: static;
        margin-left: auto;
        background: none;
        border: none;
        color: #fff;
        cursor: pointer;
        font-size: 18px;
        line-height: 24px;
      }
      .toggle-btn:hover { color: #ddd; }
      .toggle-btn::before { content: "◀"; }
      .sidebar.collapsed .toggle-btn::before { content: "▶"; }

      /* Sidebar content (file list) */
      .sidebar-content {
        flex-grow: 1;
        overflow-y: scroll;  /* show scrollbar only when needed */
        min-height: 0;       /* allow flex child to shrink and scroll */
        padding-bottom: 10px;
      }
      .sidebar-content ul { list-style: none; margin: 0; padding: 0; }
      .sidebar-content li { margin: 0; padding: 0; border: none; }

      /* Each file-item */
      .file-item {
        margin: 8px 12px;
        padding: 12px;
        background-color: #2b2b2b;
        border-radius: 12px;
        border: 1px solid #3a3a3a;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 14px;
      }
      .file-item:hover { background-color: #3399ff; }
      .file-item.active { background-color: #007bff; color: #fff; }
      .file-item.active:hover { background-color: #0056b3; }

      /* Channel pills */
      .channel-bar { display: flex; gap: 4px; margin-top: 6px; flex-wrap: nowrap; overflow-x: auto; }
      .channel-chip {
        background-color: #3a3a3a; color: #fff;
        border: 1px solid #454545;
        padding: 6px 0; border-radius: 6px; cursor: grab; user-select: none;
        flex: 1; box-sizing: border-box; text-align: center;
      }
      .channel-chip:active { cursor: grabbing; }

      /* ---- ADDED: Always show and style the HORIZONTAL scrollbar on each .channel-bar ---- */
      .channel-bar {
        scrollbar-gutter: stable;   /* reserve space so the bar is always visible */
        scrollbar-width: auto;      /* Firefox: show normal-width scrollbar */
      }
      .channel-bar::-webkit-scrollbar {
        height: 10px;               /* horizontal bar height (Chromium/Edge/WebKit) */
      }
      .channel-bar::-webkit-scrollbar-thumb {
        background: #444;           /* draggable thumb */
        border-radius: 8px;
      }
      .channel-bar::-webkit-scrollbar-track {
        background: #222;           /* track color to match sidebar */
      }
      .channel-bar::-webkit-scrollbar-button {
        display: none;              /* hide tiny arrow buttons */
      }
      /* ---- END ADDED ---- */

      /* MAIN CONTENT */
      .main-content {
        flex-grow: 1;
        min-width: 0;
        padding: 16px;
        text-align: center;
        background: var(--card-bg);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
      }

      .main-content > :last-child { margin-bottom: 0 !important; }

      h1 { margin-bottom: 20px; }

      .image-container {
        display: flex;
        justify-content: center;
        gap: 5px;
        margin-top: 20px;
        margin-bottom: 20px;
      }

      img { border: 1px solid #2b2b2b; border-radius: 10px; background: #1b1b1b; }

      .navigation { display: flex; justify-content: center; margin-top: 20px; }

      .button {
        background-color: #007bff; color: white; border: none; padding: 10px 20px;
        font-size: 15px; margin: 0 30px; cursor: pointer; border-radius: 10px;
        min-width: 160px; text-align: center; font-weight: 600; letter-spacing: 0.2px;
      }
      .button:hover { background-color: #0056b3; }

      /* Slightly larger Analyze button to fit status text */
      .button.analyze {
        min-width: 220px;
        padding: 12px 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      /* Inline spinner shown only while loading */
      .button.analyze .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-top-color: #fff;
        border-right-color: #fff;
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
        display: none;
      }
      .button.analyze.loading .spinner { display: inline-block; }

      @keyframes spin { to { transform: rotate(360deg); } }

      .button { transition: background-color 0.3s ease; }

      #currentFileInfo { margin-top: 10px; }

      a {
        background-color: #007bff; color: #fff; text-decoration: none; padding: 10px 16px; border: none;
        border-radius: 8px; transition: background-color 0.3s, color 0.3s; margin-bottom: 0;
        font-weight: 600; letter-spacing: 0.2px;
      }
      a:hover { background-color: #0056b3; color: #fff; }

      .analysis { display: inline; }

      .analysis-actions {
        margin-top: 10px;
        display: flex;
        justify-content: center;
        gap: 10px;
      }
      .button.secondary {
        background-color: #007bff;
        border: none;
        color: #fff;
      }
      .button.secondary:hover { background-color: #0056b3; }
      .analysis-popover {
        position: fixed;
        top: 0;
        left: 0;
        width: min(420px, 94vw);
        background: var(--card-bg);
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35);
        display: none;
        z-index: 2200;
      }
      .analysis-popover.open { display: block; }
      .analysis-popover-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }
      .analysis-popover-title {
        font-size: 16px;
        font-weight: 600;
      }
      .analysis-close {
        background: transparent;
        border: none;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
      }
      .analysis-popover-body {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .analysis-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #242424;
        border: 1px solid #343434;
        color: #fff;
      }
      .analysis-toggle + .analysis-toggle {
        margin-top: 6px;
      }
      .analysis-divider {
        height: 1px;
        background: #2f2f2f;
        margin: 6px 4px;
      }
      .analysis-toggle input { display: none; }
      .analysis-switch {
        position: relative;
        width: 38px;
        height: 20px;
        background: #555;
        border-radius: 999px;
        transition: background-color 0.2s ease;
        flex: 0 0 auto;
      }
      .analysis-switch::before {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        left: 2px;
        top: 2px;
        background: #f2f2f2;
        border-radius: 50%;
        transition: transform 0.2s ease;
      }
      .analysis-toggle input:checked + .analysis-switch {
        background: #2f8f4e;
      }
      .analysis-toggle input:checked + .analysis-switch::before {
        transform: translateX(18px);
      }
      .nav-exit-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2300;
      }
      .nav-exit-modal {
        width: min(440px, 92vw);
        background: var(--card-bg);
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        padding: 24px;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35);
        text-align: left;
      }
      .nav-exit-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .nav-exit-body {
        font-size: 14px;
        color: var(--text);
        margin-bottom: 16px;
      }
      .nav-exit-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
      }
      .nav-exit-btn {
        border: none;
        border-radius: 8px;
        padding: 10px 18px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin: 0;
      }
      .nav-exit-btn .spinner {
        width: 14px;
        height: 14px;
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-top-color: #fff;
        border-right-color: #fff;
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
        display: none;
      }
      .nav-exit-btn.loading .spinner { display: inline-block; }
      .nav-exit-btn.confirm {
        background: #2a2a2a;
        color: #fff;
        border: 1px solid #3a3a3a;
      }
      .nav-exit-btn.confirm:hover { background: #343434; }
      .nav-exit-btn.cancel {
        background: var(--accent);
        color: #fff;
      }
      .nav-exit-btn.cancel:hover { background: var(--accent-dark); }

      /* Chrome / Edge / Safari */
      .sidebar-content::-webkit-scrollbar-track {
        background: #222 !important;
      }

      /* Firefox */
      .sidebar-content {
        /* first = thumb, second = track */
        scrollbar-color: #333 #222;
      }

      /* NEW: force scrollbar to always show */
      .sidebar-content {
        scrollbar-gutter: stable both-edges; /* always leave room */
        scrollbar-width: auto;               /* firefox: make sure it shows */
      }

      /* Chromium/Edge/WebKit scrollbar body & thumb */
      .sidebar-content::-webkit-scrollbar {
        width: 12px;                         /* visible width */
      }
      .sidebar-content::-webkit-scrollbar-thumb {
        background: #444;                     /* actual draggable part */
        border-radius: 8px;
      }
      .sidebar-content::-webkit-scrollbar-button {
        display: none;                        /* hide tiny arrows */
      }
    </style>

    <!-- Sortable.js for drag & drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  </head>
  <body>
    {% if messages %} {% for msg in messages %}
    <div
      style="background: #f8d7da; color: #721c24; padding: 8px; border-radius: 4px; margin: 10px 0;"
    >
      {{ msg }}
    </div>
    {% endfor %} {% endif %}

    <div class="page-container soft-fade-in">
      <!-- SIDEBAR -->
      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h2>Configuration</h2>
          <button class="toggle-btn" id="toggleSidebarBtn"></button>
        </div>
        <div class="sidebar-content">
          <ul id="fileList">
            {% for file in file_list %}
            <li>
              <div class="file-item" data-index="{{ forloop.counter0 }}" data-uuid="{{ file.uuid }}">
                {{ file.name }}
                <div class="channel-bar">
                  {% for channel in file.detected_channels %}
                  <span class="channel-chip {{ channel|lower }}">{{ channel }}</span>
                  {% endfor %}
                </div>
              </div>
            </li>
            {% endfor %}
          </ul>
        </div>
      </div>

      <!-- MAIN CONTENT -->
      <div class="main-content">
        <h1>Pre-process: <span id="fileName">{{ file_name }}</span></h1>
        <div class="analysis">
          <form action="" method="post" enctype="multipart/form-data" id="preprocessForm">
            {% csrf_token %}
            <div class="analysis-actions">
              <button type="submit" class="button analyze" id="startAnalysisButton">
                <span class="spinner" aria-hidden="true"></span>
                <span class="btn-text">Start Analysis</span>
              </button>
              <button type="button" class="button secondary" id="openAnalysisModal" aria-haspopup="true" aria-expanded="false">
                Select Statistics
              </button>
            </div>
            <div class="analysis-popover" id="analysisPopover" aria-hidden="true">
              <div class="analysis-popover-header">
                <span class="analysis-popover-title" id="analysisModalTitle">Statistics</span>
                <button type="button" class="analysis-close" id="analysisModalClose" aria-label="Close statistics">
                  X
                </button>
              </div>
              <div class="analysis-popover-body">
                <label class="analysis-toggle" id="analysisSelectAllRow">
                  <span>Select all</span>
                  <input type="checkbox" id="analysisSelectAll">
                  <span class="analysis-switch"></span>
                </label>
                <div class="analysis-divider"></div>
                {% for analysis in analyses %}
                <label class="analysis-toggle">
                  <span>{{ analysis }}</span>
                  <input type="checkbox" name="selected_analysis" value="{{ analysis }}" />
                  <span class="analysis-switch"></span>
                </label>
                {% endfor %}
              </div>
            </div>
          </form>
        </div>

        <div class="image-container" id="imageContainer">
          {% for image in images %}
            {% if forloop.first %}
              <img src="{{ image.file_location.url }}" width="500" height="500" />
            {% else %}
              <img src="{{ image.file_location.url }}" width="300" height="300" />
            {% endif %}
          {% endfor %}
        </div>

        <div class="navigation">
          <button class="button" id="prevButton">Previous Image</button>
          <button class="button" id="nextButton">Next Image</button>
        </div>

        <p id="currentFileInfo">
          Viewing file <span id="currentFileIndex">{{ current_file_index|add:1 }}</span> of {{ total_files }}
        </p>
      </div>
    </div>
    <div class="nav-exit-backdrop" id="navExitBackdrop" aria-hidden="true">
      <div class="nav-exit-modal" role="dialog" aria-modal="true" aria-labelledby="navExitTitle">
        <div class="nav-exit-title" id="navExitTitle">Leave experiment?</div>
        <div class="nav-exit-body">
          You have an active experiment session. Are you sure you want to leave this page?
        </div>
        <div class="nav-exit-actions">
          <button type="button" class="nav-exit-btn cancel" id="navExitCancel">No</button>
          <button type="button" class="nav-exit-btn confirm" id="navExitConfirm">
            <span class="spinner" aria-hidden="true"></span>
            <span class="btn-label">Yes</span>
          </button>
        </div>
      </div>
    </div>

    <script>
      // Current index & total
      let currentFileIndex = parseInt("{{ current_file_index|default:0 }}", 10);
      const totalFiles = parseInt("{{ total_files|default:1 }}", 10);

      // Sidebar elements
      const sidebar = document.getElementById("sidebar");
      const toggleBtn = document.getElementById("toggleSidebarBtn");
      const fileItems = document.querySelectorAll(".file-item");
      let analysisAbortController = null;
      let analysisPollTimer = null;
      let suppressAnalysisErrors = false;
      window.isAnalysisRunning = false;

      // Highlight active
      function updateSidebarActive() {
        fileItems.forEach((i) => i.classList.remove("active"));
        const active = document.querySelector(`.file-item[data-index="${currentFileIndex}"]`);
        if (active) active.classList.add("active");
      }
      updateSidebarActive();

      const cancelClientAnalysis = () => {
        suppressAnalysisErrors = true;
        window.isAnalysisRunning = false;
        if (analysisPollTimer) {
          clearInterval(analysisPollTimer);
          analysisPollTimer = null;
        }
        if (analysisAbortController) {
          analysisAbortController.abort();
          analysisAbortController = null;
        }
      };
      let cancelPromise = null;
      const requestAnalysisCancel = async () => {
        if (!window.isAnalysisRunning) {
          return true;
        }
        if (cancelPromise) {
          return cancelPromise;
        }
          cancelPromise = (async () => {
            cancelClientAnalysis();
            const csrfEl = document.querySelector('#preprocessForm [name=csrfmiddlewaretoken]');
            const csrfToken = csrfEl?.value;
            const cancelUrl = `/api/progress/${encodeURIComponent("{{ uuids|escapejs }}")}/cancel/`;
          try {
            await fetch(cancelUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken || '',
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: JSON.stringify({ reason: 'user_cancelled' }),
              credentials: 'same-origin',
            });
            } catch (e) { /* ignore */ }

            const customTimeout = Number.isFinite(window.CANCEL_POLLING_TIMEOUT_MS)
              ? window.CANCEL_POLLING_TIMEOUT_MS
              : 0;
            const cancelPollingTimeoutMs = customTimeout > 0 ? customTimeout : 60000;
            const deadline = Date.now() + cancelPollingTimeoutMs;
            let delay = 400;
            while (Date.now() < deadline) {
              try {
                const pollUrl = new URL(`/api/progress/${encodeURIComponent("{{ uuids|escapejs }}")}/`, window.location.origin);
                const resp = await fetch(pollUrl, { cache: 'no-store' });
                if (resp.ok) {
                  const data = await resp.json();
                  const phase = data?.phase || 'idle';
                  if (phase === 'Cancelled' || phase === 'Completed' || phase === 'idle') {
                    break;
                  }
                }
              } catch (e) { /* ignore */ }
              await new Promise((resolve) => setTimeout(resolve, delay));
              delay = Math.min(2000, Math.round(delay * 1.6));
            }
            if (Date.now() >= deadline) {
              console.warn('Cancel polling timed out.');
            }
            window.isAnalysisRunning = false;
            cancelPromise = null;
            return true;
        })();
        return cancelPromise;
      };
      window.cancelActiveAnalysis = cancelClientAnalysis;
      window.requestAnalysisCancel = requestAnalysisCancel;
      window.addEventListener("beforeunload", cancelClientAnalysis);

      function setupNavExitGuard() {
        const navLinks = document.querySelectorAll(
          '.navbar a[href="/"], .navbar a[href="/login"], .navbar a[href="/signup"], .navbar a[href="/profile"]'
        );
        const backdrop = document.getElementById('navExitBackdrop');
        const cancel = document.getElementById('navExitCancel');
        const confirm = document.getElementById('navExitConfirm');

        if (!backdrop || !cancel || !confirm) {
          return;
        }

        let pendingHref = null;
        const defaultTitle = 'Leave experiment?';
        const defaultBody = 'You have an active experiment session. Are you sure you want to leave this page?';
        const runningTitle = 'Leave experiment and cancel analysis?';
        const runningBody = 'Analysis is currently running. Leaving will cancel the analysis. Are you sure you want to leave this page?';
        const openModal = (href) => {
          pendingHref = href;
          if (window.isAnalysisRunning) {
            const titleEl = document.getElementById('navExitTitle');
            const bodyEl = document.querySelector('.nav-exit-body');
            if (titleEl) titleEl.textContent = runningTitle;
            if (bodyEl) bodyEl.textContent = runningBody;
          } else {
            const titleEl = document.getElementById('navExitTitle');
            const bodyEl = document.querySelector('.nav-exit-body');
            if (titleEl) titleEl.textContent = defaultTitle;
            if (bodyEl) bodyEl.textContent = defaultBody;
          }
          backdrop.style.display = 'flex';
          backdrop.setAttribute('aria-hidden', 'false');
        };
        const closeModal = () => {
          pendingHref = null;
          backdrop.style.display = 'none';
          backdrop.setAttribute('aria-hidden', 'true');
        };
        const handleNavClick = (event) => {
          if (!Number.isFinite(totalFiles) || totalFiles <= 0) {
            return;
          }
          event.preventDefault();
          openModal(event.currentTarget.getAttribute('href'));
        };
        navLinks.forEach((link) => link.addEventListener('click', handleNavClick));

        cancel.addEventListener('click', closeModal);
        confirm.addEventListener('click', async () => {
          if (pendingHref) {
            confirm.classList.add('loading');
            confirm.style.pointerEvents = 'none';
            confirm.disabled = true;
            const label = confirm.querySelector('.btn-label');
            if (label) {
              label.textContent = 'Cancelling';
            }
            await requestAnalysisCancel();
            window.location.href = pendingHref;
          }
        });
        backdrop.addEventListener('click', (event) => {
          if (event.target === backdrop) {
            closeModal();
          }
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeModal();
          }
        });
      }
      setupNavExitGuard();

      // Click file
      fileItems.forEach((item) => {
        item.addEventListener("click", () => {
          const idx = parseInt(item.dataset.index, 10);
          loadImage(idx);
        });
      });

      // Toggle sidebar
      toggleBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        sidebar.classList.toggle("collapsed");
      });

      // ALSO expand when collapsed sidebar area is clicked
      sidebar.addEventListener("click", (e) => {
        if (sidebar.classList.contains("collapsed")) {
          sidebar.classList.remove("collapsed");
        }
      });

      const analysisButton = document.getElementById("openAnalysisModal");
      const analysisPopover = document.getElementById("analysisPopover");
      const analysisClose = document.getElementById("analysisModalClose");

      const positionAnalysisPopover = () => {
        if (!analysisButton || !analysisPopover) return;
        const rect = analysisButton.getBoundingClientRect();
        const popoverWidth = analysisPopover.offsetWidth;
        const popoverHeight = analysisPopover.offsetHeight;
        const gutter = 12;
        let left = rect.right - popoverWidth;
        left = Math.max(gutter, Math.min(left, window.innerWidth - popoverWidth - gutter));
        let top = rect.bottom + 8;
        top = Math.max(gutter, Math.min(top, window.innerHeight - popoverHeight - gutter));
        analysisPopover.style.left = `${left}px`;
        analysisPopover.style.top = `${top}px`;
      };
      const openAnalysisPopover = () => {
        if (!analysisButton || !analysisPopover) return;
        analysisPopover.classList.add("open");
        analysisPopover.setAttribute("aria-hidden", "false");
        analysisButton.setAttribute("aria-expanded", "true");
        requestAnimationFrame(positionAnalysisPopover);
      };
      const closeAnalysisPopover = () => {
        if (!analysisButton || !analysisPopover) return;
        analysisPopover.classList.remove("open");
        analysisPopover.setAttribute("aria-hidden", "true");
        analysisButton.setAttribute("aria-expanded", "false");
      };

      if (analysisButton) {
        analysisButton.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (analysisPopover && analysisPopover.classList.contains("open")) {
            closeAnalysisPopover();
          } else {
            openAnalysisPopover();
          }
        });
      }
      if (analysisClose) {
        analysisClose.addEventListener("click", (event) => {
          event.preventDefault();
          closeAnalysisPopover();
        });
      }
      if (analysisPopover) {
        analysisPopover.addEventListener("click", (event) => {
          event.stopPropagation();
        });
      }
      document.addEventListener("click", () => {
        closeAnalysisPopover();
      });
      window.addEventListener("resize", () => {
        if (analysisPopover && analysisPopover.classList.contains("open")) {
          positionAnalysisPopover();
        }
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeAnalysisPopover();
        }
      });

      const selectionKey = "yeastweb.selected_analyses";
      const initializedKey = "yeastweb.selected_analyses_initialized";
      const selectAllToggle = document.getElementById("analysisSelectAll");
      const analysisToggles = Array.from(
        document.querySelectorAll('input[name="selected_analysis"]')
      );

      const syncSelectAll = () => {
        if (!selectAllToggle) return;
        const allChecked =
          analysisToggles.length > 0 &&
          analysisToggles.every((toggle) => toggle.checked);
        selectAllToggle.checked = allChecked;
      };

      const persistSelection = () => {
        const selected = analysisToggles
          .filter((toggle) => toggle.checked)
          .map((toggle) => toggle.value);
        localStorage.setItem(selectionKey, JSON.stringify(selected));
        localStorage.setItem(initializedKey, "1");
        syncSelectAll();
      };

      const loadSelection = () => {
        const initialized = localStorage.getItem(initializedKey) === "1";
        let stored = [];
        try {
          stored = JSON.parse(localStorage.getItem(selectionKey) || "[]");
        } catch (e) {
          stored = [];
        }
        if (!initialized) {
          analysisToggles.forEach((toggle) => {
            toggle.checked = true;
          });
          persistSelection();
          return;
        }
        if (!Array.isArray(stored)) {
          stored = [];
        }
        analysisToggles.forEach((toggle) => {
          toggle.checked = stored.includes(toggle.value);
        });
        syncSelectAll();
      };

      if (selectAllToggle) {
        selectAllToggle.addEventListener("change", () => {
          const target = selectAllToggle.checked;
          analysisToggles.forEach((toggle) => {
            toggle.checked = target;
          });
          persistSelection();
        });
      }
      analysisToggles.forEach((toggle) => {
        toggle.addEventListener("change", persistSelection);
      });
      loadSelection();

      // Next / Prev buttons
      document.getElementById("nextButton").addEventListener("click", () => {
        loadImage((currentFileIndex + 1) % totalFiles);
      });
      document.getElementById("prevButton").addEventListener("click", () => {
        loadImage((currentFileIndex - 1 + totalFiles) % totalFiles);
      });

      // Intercept submit: disable inputs, poll accurate progress, POST via fetch, then navigate
      document.getElementById("preprocessForm").addEventListener("submit", async (e) => {
        e.preventDefault();
        const form = document.getElementById("preprocessForm");
        const btn = document.getElementById("startAnalysisButton");
        const textEl = btn.querySelector(".btn-text");
        suppressAnalysisErrors = false;
        window.isAnalysisRunning = true;

        btn.disabled = true;
        btn.classList.add("loading");
        btn.style.pointerEvents = "none";
        btn.style.cursor = "not-allowed";
        btn.style.backgroundColor = "#0056b3";
        if (textEl) textEl.textContent = "Processing Images";

        // Disable other interactive controls
        if (analysisButton) {
          analysisButton.disabled = true;
          analysisButton.style.pointerEvents = "none";
          analysisButton.style.opacity = "0.8";
          analysisButton.style.backgroundColor = "#0056b3";
        }
        if (analysisPopover) {
          analysisPopover.classList.remove("open");
          analysisPopover.setAttribute("aria-hidden", "true");
        }
        document.querySelectorAll(".channel-bar").forEach(bar => {
          bar.style.pointerEvents = "none";
        });

        // Reset server-side phase immediately to avoid stale reads
        try {
          const csrfEl = document.querySelector('#preprocessForm [name=csrfmiddlewaretoken]');
          const csrfToken = csrfEl?.value;
          if (csrfToken) {
            const setUrl = new URL(`/api/progress/${encodeURIComponent("{{ uuids|escapejs }}")}/set/`, window.location.origin);
            await fetch(setUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
              },
              body: JSON.stringify({ phase: 'Preprocessing Images' }),
              credentials: 'same-origin',
            });
          } else {
            console.warn('CSRF token not found; skipping progress reset.');
          }
        } catch (e) { /* ignore */ }

        // Poll progress for accurate phases
        const uuids = "{{ uuids|escapejs }}";
        analysisPollTimer = null;
        const startPolling = () => {
          const poll = async () => {
            try {
              const pollUrl = new URL(`/api/progress/${encodeURIComponent(uuids)}/`, window.location.origin);
              const resp = await fetch(pollUrl, { cache: 'no-store' });
              if (!resp.ok) return;
              const data = await resp.json();
              if (data && data.phase && textEl) {
                if (data.phase === "Preprocessing Images") {
                  textEl.textContent = "Processing Images";
                } else if (data.phase === "Detecting Cells") {
                  textEl.textContent = data.phase;
                } else if (data.phase === "Calculating Statistics") {
                  // Only show statistics phase if user selected at least one analysis
                  const hasStats = !!document.querySelector('input[name="selected_analysis"]:checked');
                  if (hasStats) textEl.textContent = data.phase;
                }
              }
            } catch (err) { /* ignore polling errors */ }
          };
          analysisPollTimer = setInterval(poll, 1000);
          // Kick off immediately
          poll();
        };
        startPolling();

        // Submit via fetch, allowing backend to run through redirects
        try {
          analysisAbortController = new AbortController();
            const resp = await fetch(window.location.href, {
              method: 'POST',
              headers: { 'X-Requested-With': 'XMLHttpRequest' },
              body: new FormData(form),
              credentials: 'same-origin',
              redirect: 'follow',
            signal: analysisAbortController.signal,
          });
          if (analysisPollTimer) clearInterval(analysisPollTimer);
          // Navigate to final URL (display page) once processing completes
          if (resp && resp.url) {
            window.isAnalysisRunning = false;
            window.location.href = resp.url;
          } else {
            window.isAnalysisRunning = false;
            window.location.href = `/image/{{ uuids }}/display/`;
          }
        } catch (err) {
          if (analysisPollTimer) clearInterval(analysisPollTimer);
          if (suppressAnalysisErrors || (err && err.name === "AbortError")) {
            return;
          }
          window.isAnalysisRunning = false;
          // On error, re-enable button minimally and surface a message
          btn.disabled = false;
          btn.classList.remove("loading");
          if (textEl) textEl.textContent = "Start Analysis";
          alert('Failed to start analysis. Please try again.');
        }
      });

      // AJAX load
      function loadImage(newIndex) {
        if (newIndex < 0) newIndex = totalFiles - 1;
        if (newIndex >= totalFiles) newIndex = 0;
        fetch(`?file_index=${newIndex}&total_files=${totalFiles}`, {
          headers: { "X-Requested-With": "XMLHttpRequest" },
        })
          .then((r) => r.json())
          .then((data) => {
            const container = document.getElementById("imageContainer");
            container.innerHTML = "";
            data.images.forEach((img, i) => {
              const el = document.createElement("img");
              el.src = img.file_location.url;
              if (i === 0) { el.width = 500; el.height = 500; }
              else { el.width = 300; el.height = 300; }
              container.appendChild(el);
            });
            document.getElementById("fileName").textContent = data.file_name;
            document.getElementById("currentFileIndex").textContent = data.current_file_index + 1;
            currentFileIndex = data.current_file_index;
            updateSidebarActive();
          });
      }
    </script>

    <script>
      // CSRF helper
      function getCookie(name) {
        let val = null;
        document.cookie.split(";").forEach((c) => {
          c = c.trim();
          if (c.startsWith(name + "=")) {
            val = decodeURIComponent(c.slice(name.length + 1));
          }
        });
        return val;
      }

      // Make each .channel-bar sortable
      document.querySelectorAll(".channel-bar").forEach((bar) => {
        const uuid = bar.parentElement.dataset.uuid;
        Sortable.create(bar, {
          animation: 150,
          onEnd() {
            const newOrder = Array.from(bar.children).map((chip) => chip.textContent);
            fetch(`/api/update-channel-order/${uuid}/`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": getCookie("csrftoken"),
              },
              body: JSON.stringify({ order: newOrder }),
            }).then((r) => {
              if (!r.ok) console.error("Failed to save channel order", r);
            });
          },
        });
      });
    </script>

    <!-- Sidebar Code -->
    <script>
      (function () {
        function clampSidebar() {
          var sidebar = document.getElementById('sidebar');
          if (!sidebar) return;
          var header  = sidebar.querySelector('.sidebar-header');
          var content = sidebar.querySelector('.sidebar-content');
          if (!content) return;

          var sidebarH = sidebar.getBoundingClientRect().height;

          var headerH = header ? header.getBoundingClientRect().height : 0;
          var hs = header ? getComputedStyle(header) : null;
          var headerMargins = hs ? (parseFloat(hs.marginTop) || 0) + (parseFloat(hs.marginBottom) || 0) : 0;

          var cs = getComputedStyle(content);
          var vPad = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);

          var maxH = Math.max(0, Math.floor(sidebarH - headerH - headerMargins - vPad));
          content.style.maxHeight = maxH + 'px';
          content.style.overflowY = 'auto';
          content.style.minHeight = '0';
        }

        window.addEventListener('load', function () {
          requestAnimationFrame(clampSidebar);
          setTimeout(clampSidebar, 0);
        });
        window.addEventListener('resize', clampSidebar);

        var sidebarEl = document.getElementById('sidebar');
        if (sidebarEl) {
          sidebarEl.addEventListener('transitionend', function (e) {
            if (e.propertyName === 'width') clampSidebar();
          });
        }

        if ('ResizeObserver' in window) {
          var main = document.querySelector('.main-content');
          if (main) new ResizeObserver(clampSidebar).observe(main);
        }
      })();
    </script>
  </body>
</html>
{% endblock content %}
